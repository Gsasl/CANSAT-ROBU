// CANSAT_Sensor_Broadcast.ino (USB‑B ESP32)
// Libraries: WiFi, HTTPClient, Wire, MPU6500_WE, Adafruit_BMP280, QMC5883LCompass
// Optional: HardwareSerial for GPS (NMEA)

// ---------- Wi-Fi (AP from the USB‑C ESP32) ----------
#include <WiFi.h>
#include <HTTPClient.h>

const char* WIFI_SSID = "CANSAT_AP";
const char* WIFI_PASS = "CANSAT123";
const char* AP_HOST   = "192.168.4.1";
const uint16_t AP_PORT = 80;
const unsigned long postIntervalMs = 1000;

// ---------- Sensors ----------
#include <Wire.h>
#include <MPU6500_WE.h>
#include <Adafruit_BMP280.h>
#include <QMC5883LCompass.h>
#include <HardwareSerial.h>

#define MPU6500_ADDR 0x68
TwoWire MPU_Wire = TwoWire(1); // for MPU on custom pins
MPU6500_WE myMPU(&MPU_Wire);

Adafruit_BMP280 bmp; // default Wire (SDA 21, SCL 22)
QMC5883LCompass compass;

HardwareSerial GPS_Serial(2);
#define RXD2 16
#define TXD2 17

// ---------- Calibration / filters ----------
const float alpha = 0.2f;
float fAccX=0, fAccY=0, fAccZ=0;
float fGyrX=0, fGyrY=0, fGyrZ=0;

float accelOffsetX=0, accelOffsetY=0, accelOffsetZ=0;
float gyroOffsetX=0,  gyroOffsetY=0,  gyroOffsetZ=0;

bool bmpAvailable = false;
float baselinePressure = 1013.25;

bool calibrating = true;
unsigned long calibrationStartTime;
const unsigned long calibrationDuration = 30000; // 30s
int minX=32767,maxX=-32768,minY=32767,maxY=-32768,minZ=32767,maxZ=-32768;
float offsetX=0,offsetY=0,offsetZ=0;

const float compassAlpha = 0.09f;
const float deadZone = 10.0f;
float smoothedHeading = 0;

String gpsBuffer = "";
float gpsLatitude = 0.0f, gpsLongitude = 0.0f;
bool gpsFixAvailable = false;

// ---------- Helpers ----------
void connectWiFi() {
  if (WiFi.status() == WL_CONNECTED) return;
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  unsigned long t0 = millis();
  Serial.print("Connecting to "); Serial.print(WIFI_SSID);
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 15000) { delay(250); Serial.print("."); }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("STA IP: "); Serial.println(WiFi.localIP());
  } else {
    Serial.println("WiFi connect failed.");
  }
}

bool postJSON(const String& json) {
  if (WiFi.status() != WL_CONNECTED) connectWiFi();
  if (WiFi.status() != WL_CONNECTED) return false;
  HTTPClient http;
  String url = String("http://") + AP_HOST + ":" + String(AP_PORT) + "/ingest";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  int code = http.POST((uint8_t*)json.c_str(), json.length());
  http.end();
  return code >= 200 && code < 300;
}

String getDirection(float heading) {
  if ((heading >= 0 && heading < 22.5) || (heading >= 337.5)) return "North";
  if (heading < 67.5) return "North-East";
  if (heading < 112.5) return "East";
  if (heading < 157.5) return "South-East";
  if (heading < 202.5) return "South";
  if (heading < 247.5) return "South-West";
  if (heading < 292.5) return "West";
  return "North-West";
}

void parseGPS(String nmea) {
  // Very light GGA/RMC parser (as in your prior approach)
  int fieldIndex = 0; String fields[20]; int start = 0;
  for (int i = 0; i < nmea.length(); i++) {
    if (nmea[i] == ',' || nmea[i] == '*') { fields[fieldIndex++] = nmea.substring(start, i); start = i + 1; }
  }
  auto conv = [](String rawCoord, String direction) {
    if (rawCoord.length() < 3) return 0.0f;
    float degMin = rawCoord.toFloat(); int degrees = int(degMin / 100.0f);
    float minutes = degMin - (degrees * 100.0f);
    float dec = degrees + minutes / 60.0f;
    if (direction == "S" || direction == "W") dec *= -1;
    return dec;
  };
  if (nmea.startsWith("$GPGGA")) {
    if (fields[2] != "" && fields[4] != "") {
      gpsLatitude = conv(fields[2], fields[3]);
      gpsLongitude = conv(fields[4], fields[5]);
      gpsFixAvailable = true;
    } else gpsFixAvailable = false;
  } else if (nmea.startsWith("$GPRMC")) {
    if (fields[2] == "A" && fields[3] != "" && fields[5] != "") {
      gpsLatitude = conv(fields[3], fields[4]);
      gpsLongitude = conv(fields[5], fields[6]);
      gpsFixAvailable = true;
    } else gpsFixAvailable = false;
  }
}

void calibrateMPU() {
  Serial.println("Calibrating MPU6500 (flat/still)...");
  delay(2000);
  const int N=120;
  float sAx=0,sAy=0,sAz=0,sGx=0,sGy=0,sGz=0;
  for (int i=0;i<N;i++){
    xyzFloat a = myMPU.getAccRawValues();
    xyzFloat g = myMPU.getGyrRawValues();
    sAx += a.x; sAy += a.y; sAz += a.z;
    sGx += g.x; sGy += g.y; sGz += g.z;
    delay(8);
  }
  accelOffsetX = sAx/N; accelOffsetY = sAy/N; accelOffsetZ = (sAz/N) - 4096; // 1g on Z
  gyroOffsetX = sGx/N; gyroOffsetY = sGy/N; gyroOffsetZ = sGz/N;
  Serial.println("MPU6500 calibration done.");
}

void setup() {
  Serial.begin(115200);
  // I2C default for BMP/compass
  Wire.begin(21,22);
  // Compass
  compass.init();

  // BMP280
  if (bmp.begin(0x76)) {
    bmpAvailable = true;
    delay(100);
    const int samples=200; float sum=0;
    for (int i=0;i<samples;i++){ sum += bmp.readPressure()/100.0f; delay(5); }
    baselinePressure = sum/samples;
    Serial.print("BMP280 baseline hPa: "); Serial.println(baselinePressure,2);
  } else {
    Serial.println("BMP280 not found.");
  }

  // MPU6500 on Wire1 (18,19)
  MPU_Wire.begin(18,19,400000);
  if (!myMPU.init()) {
    Serial.println("MPU6500 init failed!");
  } else {
    myMPU.setAccRange(MPU6500_ACC_RANGE_8G);
    myMPU.setGyrRange(MPU6500_GYRO_RANGE_500);
    myMPU.setSampleRateDivider(5);
    myMPU.setAccDLPF(MPU6500_DLPF_4);
    myMPU.enableAccDLPF(true);
    calibrateMPU();
  }

  // GPS
  GPS_Serial.begin(9600, SERIAL_8N1, RXD2, TXD2);
  calibrationStartTime = millis();
  Serial.println("Rotate for 30s to calibrate compass...");
  connectWiFi();
}

void loop() {
  // GPS read
  while (GPS_Serial.available()) {
    char c = GPS_Serial.read();
    if (c == '\n') {
      gpsBuffer.trim();
      if (gpsBuffer.startsWith("$GPGGA") || gpsBuffer.startsWith("$GPRMC")) parseGPS(gpsBuffer);
      gpsBuffer = "";
    } else gpsBuffer += c;
  }

  // MPU
  xyzFloat a = myMPU.getAccRawValues();
  xyzFloat g = myMPU.getGyrRawValues();
  float accX = a.x - accelOffsetX;
  float accY = a.y - accelOffsetY;
  float accZ = a.z - accelOffsetZ;
  float gyrX = g.x - gyroOffsetX;
  float gyrY = g.y - gyroOffsetY;
  float gyrZ = g.z - gyroOffsetZ;
  // convert
  float accX_ms2 = (accX/4096.0f)*9.80665f;
  float accY_ms2 = (accY/4096.0f)*9.80665f;
  float accZ_ms2 = (accZ/4096.0f)*9.80665f;
  float gyrX_dps = (gyrX/65.5f);
  float gyrY_dps = (gyrY/65.5f);
  float gyrZ_dps = (gyrZ/65.5f);
  // smooth
  fAccX = (1-alpha)*fAccX + alpha*accX_ms2;
  fAccY = (1-alpha)*fAccY + alpha*accY_ms2;
  fAccZ = (1-alpha)*fAccZ + alpha*accZ_ms2;
  fGyrX = (1-alpha)*fGyrX + alpha*gyrX_dps;
  fGyrY = (1-alpha)*fGyrY + alpha*gyrY_dps;
  fGyrZ = (1-alpha)*fGyrZ + alpha*gyrZ_dps;

  // BMP
  float temperature = NAN, pressure = NAN, altitude = NAN;
  if (bmpAvailable) {
    pressure = bmp.readPressure()/100.0f;
    temperature = bmp.readTemperature();
    altitude = 44330.0f * (1.0f - powf(pressure / baselinePressure, 0.1903f));
  }

  // Compass calibration (first 30s)
  compass.read();
  int rawX = compass.getX(), rawY = compass.getY(), rawZ = compass.getZ();
  if (calibrating) {
    if (rawX < minX) minX = rawX; if (rawX > maxX) maxX = rawX;
    if (rawY < minY) minY = rawY; if (rawY > maxY) maxY = rawY;
    if (rawZ < minZ) minZ = rawZ; if (rawZ > maxZ) maxZ = rawZ;
    if (millis() - calibrationStartTime >= calibrationDuration) {
      calibrating = false;
      offsetX = (maxX + minX)/2.0f; offsetY = (maxY + minY)/2.0f; offsetZ = (maxZ + minZ)/2.0f;
      Serial.println("Compass calibration complete.");
    }
    delay(200);
    return;
  }

  float calX = rawX - offsetX;
  float calY = rawY - offsetY;
  if (!(fabs(calX) < deadZone && fabs(calY) < deadZone)) {
    float heading = atan2f(calY, calX) * 180.0f / PI;
    if (heading < 0) heading += 360.0f;
    smoothedHeading = compassAlpha*heading + (1.0f-compassAlpha)*smoothedHeading;
  }
  float displayHeading = roundf(smoothedHeading*10.0f)/10.0f;
  String direction = getDirection(displayHeading);

  static unsigned long lastPost = 0;
  if (millis() - lastPost >= postIntervalMs) {
    lastPost = millis();
    // Compose JSON
    String json = "{";
    json += "\"ts\":" + String(millis());
    json += ",\"temp\":" + (isnan(temperature) ? String("null") : String(temperature,2));
    json += ",\"press\":" + (isnan(pressure) ? String("null") : String(pressure,2));
    json += ",\"alt\":" + (isnan(altitude) ? String("null") : String(altitude,2));
    json += ",\"accX\":" + String(fAccX,2);
    json += ",\"accY\":" + String(fAccY,2);
    json += ",\"accZ\":" + String(fAccZ,2);
    json += ",\"gyrX\":" + String(fGyrX,2);
    json += ",\"gyrY\":" + String(fGyrY,2);
    json += ",\"gyrZ\":" + String(fGyrZ,2);
    json += ",\"heading\":" + String(displayHeading,1);
    json += ",\"dir\":\"" + direction + "\"";
    if (gpsFixAvailable) {
      json += ",\"lat\":" + String(gpsLatitude,6);
      json += ",\"lon\":" + String(gpsLongitude,6);
    } else {
      json += ",\"lat\":null,\"lon\":null";
    }
    json += "}";

    bool ok = postJSON(json);
    if (!ok) {
      Serial.println("WARN: POST failed; will retry.");
    }
  }

  delay(10);
}
